"""
This module has all models in project due to current cython dataclass implementation.
Should be split to different files when possible.
"""
import asyncio
import base64
import dataclasses
import json
import os
import time
import typing
from hashlib import sha3_512

import bson
import cython
import pymongo
from motor.motor_asyncio import AsyncIOMotorClient

from common import exceptions
from common.config import Config
from common.dataclass cimport BaseDataclass
from common.json import JsonEncoder


@cython.cclass
cdef class DocumentBase(BaseDataclass):
    __primary_key__ = "_id"

    NotFoundError = exceptions.DocumentNotFound

    @property
    def primary_key(self):
        return getattr(self, self.__primary_key__)

    @classmethod
    def client(cls):
        return AsyncIOMotorClient(Config().MONGO_URI)

    @classmethod
    def sync_client(cls):
        return pymongo.MongoClient(Config().MONGO_URI)

    @classmethod
    def database(cls):
        return cls.client()[cls.__database__]

    @classmethod
    def sync_database(cls):
        return cls.sync_client()[cls.__database__]

    @classmethod
    def collection(cls):
        return cls.database()[cls.__collection__]

    @classmethod
    def sync_collection(cls):
        return cls.sync_database()[cls.__collection__]

    @classmethod
    async def one(cls, document_id=None, add_query=None, required=True, **kwargs):
        """Finds one document by ID."""

        query = {}
        if document_id is not None:
            query["_id"] = document_id
        if add_query is not None:
            query.update(add_query)

        result = await cls.collection().find_one(query, **kwargs)
        if result is not None:
            return cls(**cls.convert_dataclasses(result))
        elif required:
            raise cls.NotFoundError()

    @classmethod
    async def all(cls, document_ids=None, add_query=None, **kwargs):
        """Finds all documents based in IDs."""

        query = {}
        if document_ids is not None:
            query["_id"] = {"$in": document_ids}
        if add_query is not None:
            query.update(add_query)

        documents = []
        async_for = True

        cursor = cls.collection().find(query, **kwargs)
        if isinstance(cursor, typing.Coroutine):
            cursor = await cursor
            async_for = False

        if async_for:
            async for document in cursor:
                documents.append(cls(**document))
        else:
            for document in cursor:
                documents.append(cls(**document))
        return documents

    def delete(self):
        """Deletes document from collection."""

        return self.collection().delete_one(
            {self.__primary_key__: getattr(self, self.__primary_key__)}
        )

    async def commit_changes(self, fields=None):
        """Saves changed document to collection."""

        search_query = {self.__primary_key__: getattr(self, self.__primary_key__)}
        update_query = {"$set": {}}
        fields = (
            fields
            if fields is not None
            else [field for field in self._fields if not field.startswith("__")]
        )

        for field in fields:
            value = getattr(self, field)
            update_query["$set"].update(
                {
                    field: value.to_dict()
                    if isinstance(value, BaseDataclass)
                    else json.dumps(value, cls=JsonEncoder)
                }
            )
        print(search_query, update_query)
        return await self.collection().update_one(search_query, update_query)

    async def insert(self):
        """Inserts document into collection."""

        return await self.collection().insert_one(self.to_dict())


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Document(DocumentBase):
    _id: str = cython.dataclasses.field(default_factory=lambda: str(bson.ObjectId()))


class MetaDocumentMixin(type):
    def __new__(mcs, name, bases, namespace):
        fields = []
        for field in dataclasses.fields(Document):
            field.kw_only = True
            fields.append((field.name, field.type, field))
        return dataclasses.make_dataclass(
            name, fields=fields, bases=bases, namespace=namespace
        )

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class GameAuth(BaseDataclass):
    server_id: cython.char
    play_ok1: ctype.int32
    play_ok2: ctype.int32
    login_ok1: ctype.int32
    login_ok2: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Account(Document):
    id: cython.int
    username: str
    password: str

    __collection__ = "accounts"
    __database__ = "l2py"

    status: cython.char = 0
    last_server: ctype.int32 = 0
    last_character: str = ""
    email: str = ""
    salt: str = ""
    game_auth: GameAuth = None

    @classmethod
    async def create_index(cls):
        return await cls.collection().create_index(
            [
                ("username", pymongo.ASCENDING),
            ]
        )

    @classmethod
    async def new(cls, username: str, password: str):
        """Constructs new account."""

        new_id = await IDFactory.get_new_id(IDFactory.NAME_ACCOUNTS)
        acc = Account(
            id=new_id,
            username=username,
            password="",
        )
        await acc.insert()
        await acc.set_new_password(password=password)
        return acc

    @classmethod
    async def one(
        cls, document_id=None, username=None, add_query=None, **kwargs
    ) -> Account:
        """Finds one account."""

        query = {}
        if document_id is not None:
            query["_id"] = document_id
        if username is not None:
            query["username"] = username

        query.update(add_query or {})

        return await super().one(add_query=query, **kwargs)

    async def set_new_password(self, password: str):
        """Sets new password for user.

        :param password: User defined password.
        """
        salt = base64.b64encode(os.urandom(20)).decode()
        salted_password = password + salt
        self.password = base64.b64encode(
            sha3_512(salted_password.encode()).digest()
        ).decode()
        self.salt = salt
        await self.commit_changes(fields=["salt", "password"])

    def authenticate(self, password) -> bool:
        """Checks that provided password matches database one.

        :param password: User defined password.
        :return: are passwords match
        """

        salted_password = password + self.salt
        hashed_password = base64.b64encode(
            sha3_512(salted_password.encode()).digest()
        ).decode()
        return self.password == hashed_password

    @classmethod
    async def create_indexes(cls):
        await cls.collection().create_index(
            [
                ("username", pymongo.ASCENDING),
            ],
            unique=True,
        )

    async def login_authenticated(
        self, server_id, play_ok1, play_ok2, login_ok1, login_ok2
    ):
        """Saves information for game server auth."""

        self.game_auth = GameAuth(
            server_id=server_id,
            play_ok1=play_ok1,
            play_ok2=play_ok2,
            login_ok1=login_ok1,
            login_ok2=login_ok2,
        )
        print(self.game_auth)
        await self.commit_changes(fields=["game_auth"])


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
class GameServer(Document):
    __collection__ = "game_servers"
    __database__ = "l2py"

    __encode__ = (
        "id",
        "host_as_bytearray",
        "port",
        "age_limit",
        "is_pvp",
        "online_count",
        "max_online",
        "server_is_alive",
        "type",
        "brackets",
    )

    @property
    def is_full(self) -> cython.bint:
        return self.online_count >= self.max_online

    @property
    def host_as_bytearray(self) -> bytearray:
        return bytearray([int(i) for i in self.host.split(".")])

    @property
    def server_is_alive(self) -> cython.bint:
        return self.last_alive >= time.time() - 15

    @classmethod
    async def one(cls, server_id, **kwargs) -> GameServer:
        return await super().one(add_query={"id": int(server_id)}, **kwargs)


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class IDFactory(Document):
    __collection__ = "id_factory"
    __database__ = "l2py"

    NAME_ITEMS = "items"
    NAME_CHARACTERS = "characters"
    NAME_ACCOUNTS = "accounts"

    name: str
    counter: ctype.int32 = 1

    @classmethod
    async def get_new_id(cls, object_type_name: str):
        item_id_factory = await cls.one(
            add_query={"name": object_type_name}, required=False
        )
        if item_id_factory is None:
            item_id_factory = cls(name=object_type_name, _id=str(bson.ObjectId()))
            await item_id_factory.insert()
        asyncio.Task(item_id_factory.increment())
        return item_id_factory.counter

    async def increment(self):
        self.collection().update_one({"_id": self._id}, {"$inc": {"counter": 1}})


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class CharacterBase(CharacterStructure):
    account_username: str

    sex: ctype.int32
    race: ctype.int32
    base_class: ctype.int32
    active_class: ctype.int32

    appearance: CharacterAppearance

    delete_at: ctype.int32
    friends: list[ctype.int32]
    inventory: Inventory

    active: ctype.int32 = 0
    karma: ctype.int32 = 0

    pk_kills: ctype.int32 = 0
    pvp_kills: ctype.int32 = 0

    __database__ = "l2py"
    __collection__ = "characters"

    @property
    def time_until_deletion(self) -> ctype.int32:
        return self.delete_at - time.time() if self.delete_at else 0

    @classmethod
    async def all(cls, account_username=None, **kwargs):
        return await super().all(
            add_query={"account_username": account_username}, **kwargs
        )

    @classmethod
    async def from_template(
        cls,
        template: CharacterTemplate,
        name,
        account,
        sex,
        race,
        face,
        hair_style,
        hair_color,
    ):

        status = Status(
            hp=template.stats.max_hp,
            cp=template.stats.max_cp,
            mp=template.stats.max_cp,
        )

        position = Position(point3d=template.spawn)

        return cls(
            id=await IDFactory.get_new_id(IDFactory.NAME_CHARACTERS),
            account_username=account.username,
            is_visible=True,
            name=name,
            status=status,
            template=template,
            position=position,
            stats=template.stats,
            sex=sex,
            race=race,
            base_class=template.class_info.id,
            active_class=template.class_info.id,
            hair_style=hair_style,
            hair_color=hair_color,
            face=face,
        )

    async def mark_deleted(self):
        self.delete_at = time.time() + 7 * 24 * 60 * 60
        await self.commit_changes(fields=["delete_at"])

    async def remove_deleted_mark(self):
        self.delete_at = 0
        await self.commit_changes(fields=["delete_at"])

    def __hash__(self):
        return hash(f"{self.id}_{self.name}")


@dataclasses.dataclass(kw_only=True)
class Character(CharacterBase, DocumentBase, metaclass=MetaDocumentMixin):
    pass


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class L2Object(BaseDataclass):
    id: ctype.int32
    name: str
    position: Position
    is_visible: cython.bint
    poly: ObjectPolymorph


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Playable(L2Object):
    target: Playable = None

    def set_target(self, target: Playable):
        self.target = target

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Point3D(BaseDataclass):
    x: ctype.int32
    y: ctype.int32
    z: ctype.int32

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class ObjectPolymorph(BaseDataclass):
    id: ctype.int32
    type: ctype.int32

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Position(BaseDataclass):
    heading_angle: ctype.int32
    point3d: Point3D
    region: WorldRegion

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Armor(Item):
    avoid_modifier: ctype.int32
    physical_defense: ctype.int32
    magic_defense: ctype.int32
    mp_bonus: ctype.int32
    hp_bonus: ctype.int32

    passive_skill: typing.Union[None, Skill] = None


cdef class EtcItemType:
    ARROW = 0
    MATERIAL = 1
    PET_COLLAR = 2
    POTION = 3
    RECIPE = 4
    SCROLL = 5
    QUEST = 6
    MONEY = 7
    OTHER = 8
    SPELLBOOK = 9
    SEED = 10
    SHOT = 11
    HERB = 12


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class EtcItem(Item):
    @property
    def is_consumable(self):
        return self.type in [EtcItemType.SHOT, EtcItemType.POTION]

PAPERDOLL_UNDER_ID: ctype.int32 = 0
PAPERDOLL_LEFT_EAR_ID: ctype.int32 = 1
PAPERDOLL_RIGHT_EAR_ID: ctype.int32 = 2
PAPERDOLL_NECK_ID: ctype.int32 = 3
PAPERDOLL_LEFT_FINGER_ID: ctype.int32 = 4
PAPERDOLL_RIGHT_FINGER_ID: ctype.int32 = 5
PAPERDOLL_HEAD_ID: ctype.int32 = 6
PAPERDOLL_RIGHT_HAND_ID: ctype.int32 = 7
PAPERDOLL_LEFT_HAND_ID: ctype.int32 = 8
PAPERDOLL_GLOVES_ID: ctype.int32 = 9
PAPERDOLL_CHEST_ID: ctype.int32 = 10
PAPERDOLL_LEGS_ID: ctype.int32 = 11
PAPERDOLL_FEET_ID: ctype.int32 = 12
PAPERDOLL_BACK_ID: ctype.int32 = 13
PAPERDOLL_DOUBLE_HANDED_ID: ctype.int32 = 14
PAPERDOLL_FACE_ID: ctype.int32 = 15
PAPERDOLL_HAIR_ID: ctype.int32 = 16
PAPERDOLL_DOUBLE_HAIR_ID: ctype.int32 = 17
PAPERDOLL_TOTAL_SLOTS_SUM: ctype.int32 = 17

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class PaperDoll(BaseDataclass):
    # all_items_ids = [
    #     under_id,
    #     left_ear_id,
    #     right_ear_id,
    #     neck_id,
    #     left_finger_id,
    #     right_finger_id,
    #     head_id,
    #     right_hand_id,
    #     left_hand_id,
    #     gloves_id,
    #     chest_id,
    #     legs_id,
    #     feet_id,
    #     back_id,
    #     double_handed_id,
    #     face_id,
    #     hair_id,
    #     double_hair_id,
    # ]

    under: Armor = None
    left_ear: Armor = None
    right_ear: Armor = None
    neck: Armor = None
    left_finger: Armor = None
    right_finger: Armor = None
    head: Armor = None
    right_hand: Weapon = None
    left_hand: Weapon = None
    gloves: Armor = None
    chest: Armor = None
    legs: Armor = None
    feet: Armor = None
    back: Armor = None
    face: Armor = None
    hair: Armor = None
    hair_all: Armor = None
    double_handed: Weapon = None

    def by_id(self, item_slot_id: ctype.int32):
        """Finds item by its slot ID."""

        return {
            PAPERDOLL_UNDER_ID: self.under,
            PAPERDOLL_LEFT_EAR_ID: self.left_ear,
            PAPERDOLL_RIGHT_EAR_ID: self.right_ear,
            PAPERDOLL_NECK_ID: self.neck,
            PAPERDOLL_LEFT_FINGER_ID: self.left_finger,
            PAPERDOLL_RIGHT_FINGER_ID: self.right_finger,
            PAPERDOLL_HEAD_ID: self.head,
            PAPERDOLL_RIGHT_HAND_ID: self.right_hand,
            PAPERDOLL_LEFT_HAND_ID: self.left_hand,
            PAPERDOLL_GLOVES_ID: self.gloves,
            PAPERDOLL_CHEST_ID: self.chest,
            PAPERDOLL_LEGS_ID: self.legs,
            PAPERDOLL_FEET_ID: self.feet,
            PAPERDOLL_BACK_ID: self.back,
            PAPERDOLL_FACE_ID: self.face,
            PAPERDOLL_HAIR_ID: self.hair,
            PAPERDOLL_DOUBLE_HAIR_ID: self.hair_all,
            PAPERDOLL_DOUBLE_HANDED_ID: self.double_handed,
        }[item_slot_id]

    def set_item(self, slot_id, item):
        if hasattr(self, slot_id):
            setattr(self, slot_id, item)

    def by_body_part_name(self, body_part_name):
        return {
            PAPERDOLL_UNDER_ID: self.under,
            PAPERDOLL_LEFT_EAR_ID: self.left_ear,
            PAPERDOLL_RIGHT_EAR_ID: self.right_ear,
            PAPERDOLL_NECK_ID: self.neck,
            PAPERDOLL_LEFT_FINGER_ID: self.left_finger,
            PAPERDOLL_RIGHT_FINGER_ID: self.right_finger,
            PAPERDOLL_HEAD_ID: self.head,
            PAPERDOLL_RIGHT_HAND_ID: self.right_hand,
            PAPERDOLL_LEFT_HAND_ID: self.left_hand,
            PAPERDOLL_GLOVES_ID: self.gloves,
            PAPERDOLL_CHEST_ID: self.chest,
            PAPERDOLL_LEGS_ID: self.legs,
            PAPERDOLL_FEET_ID: self.feet,
            PAPERDOLL_BACK_ID: self.back,
            PAPERDOLL_FACE_ID: self.face,
            PAPERDOLL_HAIR_ID: self.hair,
            PAPERDOLL_DOUBLE_HAIR_ID: self.hair_all,
            PAPERDOLL_DOUBLE_HANDED_ID: self.double_handed,
        }[body_part_name]


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Inventory(BaseDataclass):
    equipped_items: PaperDoll = None
    items: typing.List[Item] = cython.dataclasses.field(default_factory=list)

    @property
    def total_weight(self):
        weight = 0
        for item in [*self.equipped_items, *self.items]:
            weight += item.weight
        return weight

    def encode(self):
        cdef list object_ids = []
        cdef list type_ids = []
        for item_id in self.equipped_items.all_items_ids:
            if item_id == PaperDoll.double_handed_id:
                continue
            item = self.equipped_items.by_id(item_id)
            if item is not None:
                object_ids.append(item.id)
                type_ids.append(item.special_type)
            else:
                object_ids.append(0)
                type_ids.append(0)
        return [*object_ids, *type_ids]

    def equip(self, item, slot_id=None):
        """Equips item."""

        if slot_id is not None:
            current_item = self.equipped_items.by_id(slot_id)
            self.items.append(current_item)
            self.equipped_items.set_item(slot_id, item)
            self.items.pop(item)
            item.is_equipped = True

    def encode_other(self):
        """Encodes inventory as other character."""

        cdef list result = []
        required_items = [
            self.equipped_items.hair_all,
            self.equipped_items.head,
            self.equipped_items.right_hand,
            self.equipped_items.left_hand,
            self.equipped_items.gloves,
            self.equipped_items.chest,
            self.equipped_items.legs,
            self.equipped_items.feet,
            self.equipped_items.back,
            self.equipped_items.double_handed,
            self.equipped_items.hair,
            self.equipped_items.face,
        ]
        for item in required_items:
            if item is not None:
                result.append(item.id)
            else:
                result.append(0)
        return result

class Type:
    weapon_or_jewelry = 0
    shield = 1
    quest_or_adena = 4


class SpecialType:
    weapon: ctype.int32 = 0
    shield: ctype.int32 = 1
    accessory: ctype.int32 = 2
    quest: ctype.int32 = 3
    money: ctype.int32 = 4
    other: ctype.int32 = 5
    pet_wolf: ctype.int32 = 6
    pet_hatchling: ctype.int32 = 7
    pet_strider: ctype.int32 = 8
    pet_baby: ctype.int32 = 9


class Materials:
    steel: ctype.int32 = 0
    fine_steel: ctype.int32 = 1
    blood_steel: ctype.int32 = 2
    bronze: ctype.int32 = 3
    silver: ctype.int32 = 4
    gold: ctype.int32 = 5
    mithril: ctype.int32 = 6
    oriharukon: ctype.int32 = 7
    paper: ctype.int32 = 8
    wood: ctype.int32 = 9
    cloth: ctype.int32 = 10
    leather: ctype.int32 = 11
    bone: ctype.int32 = 12
    damascus: ctype.int32 = 13
    adamantaite: ctype.int32 = 14
    chrysolite: ctype.int32 = 15
    crystal: ctype.int32 = 16
    liquid: ctype.int32 = 17
    scale_of_dragon: ctype.int32 = 18
    dyestuff: ctype.int32 = 19
    coweb: ctype.int32 = 20
    seed: ctype.int32 = 21


class CrystalType:
    D: ctype.int32 = 1
    C: ctype.int32 = 2
    B: ctype.int32 = 3
    A: ctype.int32 = 4
    S: ctype.int32 = 5


class CrystalItem:
    D: ctype.int32 = 1458
    C: ctype.int32 = 1459
    B: ctype.int32 = 1460
    A: ctype.int32 = 1461
    S: ctype.int32 = 1462


class CrystalEnchantBonusArmor:
    D: ctype.int32 = 11
    C: ctype.int32 = 6
    B: ctype.int32 = 11
    A: ctype.int32 = 19
    S: ctype.int32 = 25


class CrystalEnchantBonusWeapon:
    D: ctype.int32 = 90
    C: ctype.int32 = 45
    B: ctype.int32 = 67
    A: ctype.int32 = 144
    S: ctype.int32 = 250


class Crystal:
    TYPE = CrystalType
    ITEM = CrystalItem
    BONUS_WEAPON = CrystalEnchantBonusWeapon
    BONUS_ARMOR = CrystalEnchantBonusArmor


class ItemLocation:
    VOID = 0
    INVENTORY = 1
    PAPERDOLL = 2
    WAREHOUSE = 3
    CLAN_WAREHOUSE = 4
    PET = 5
    PET_EQUIPMENT = 6
    LEASE = 7
    FREIGHT = 8


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class ItemProperties(BaseDataclass):
    crystallizable: cython.bint
    stackable: cython.bint
    sellable: cython.bint
    droppable: cython.bint
    destroyable: cython.bint
    tradable: cython.bint
    degradable: cython.bint


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Crystallization(BaseDataclass):
    type: ctype.int32 = 0
    count: ctype.int32 = 0


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class ItemTemplate(L2Object):
    type: ctype.int32
    inventory_type: ctype.int32
    special_type: ctype.int32
    weight: ctype.int32
    material: ctype.int32
    crystallization: Crystallization
    duration: ctype.int32
    body_part: str
    price: ctype.int32
    properties: ItemProperties

    skills: typing.List[Skill]
    object_id: ctype.int32

    def validate_material(self):
        if self.material not in Materials.__dict__:
            raise Exception("Unknown material")


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Item(ItemTemplate):
    owner_id: ctype.int32
    count: ctype.int32
    initial_count: ctype.int32
    usage_time: ctype.int32
    item_template: ItemTemplate
    location: ctype.int32
    slot: ctype.int32
    enchant: ctype.int32
    price_sell: ctype.int32
    price_buy: ctype.int32
    wear: cython.bint
    drop_time: ctype.int32
    protected: cython.bint

    decrease: cython.bint = False
    augmentation: ctype.int32 = None
    mana: ctype.int32 = -1
    consuming_mana: cython.bint = False
    mana_consumption_rate = 60000

    charged_soulshot: ctype.int32 = 0
    charged_spiritshot: ctype.int32 = 0
    charged_fishshot: cython.bint = False

    last_change: ctype.int32 = 2

    is_equipped: cython.bint = False
    enchant_level: ctype.int32 = 0
    crystal_type: cython.char = 0


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Weapon(Item):
    soulshot_count: ctype.int32
    spiritshot_count: ctype.int32
    physical_damage: ctype.int32
    random_damage: ctype.int32
    critical: ctype.int32
    hit_modifier: cython.double
    avoid_modifier: ctype.int32
    shield_defense_rate: cython.double
    attack_speed: ctype.int32
    attack_reuse: ctype.int32
    mp_consumption: ctype.int32
    magic_damage: ctype.int32

    passive_skill: typing.Union[None, Skill] = None
    enchant4_skill: typing.Union[None, Skill] = None

    skills_on_hit: typing.List[Skill] = ()
    skills_on_cast: typing.List[Skill] = ()

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class CharacterAppearance(BaseDataclass):
    face_id: ctype.int32
    hair_style: ctype.int32
    hair_color: ctype.int32

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class AttacksBuffs(BaseDataclass):
    physical_plants: ctype.int32 = 0
    physical_insects: ctype.int32 = 0
    physical_animals: ctype.int32 = 0
    physical_monsters: ctype.int32 = 0
    physical_dragons: ctype.int32 = 0
    physical_undead: ctype.int32 = 0

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class CharacterStructure(Playable):
    last_skill: Skill = None
    last_heal_amount: ctype.int32 = 0
    title: str = None
    ai_class: str = None
    hp_updates: UpdateChecks = None
    skills: list[Skill] = cython.dataclasses.field(default_factory=list)
    current_zone: WorldRegion = None
    name_color: ctype.int32 = 2147483647
    title_color: ctype.int32 = 2147483647

    # TODO: Find a better place for those properties
    @property
    def weight_penalty(self) -> ctype.int32:
        return 0

    @property
    def exp_penalty(self) -> ctype.int32:
        return 0

    @property
    def exp_protected(self) -> ctype.int32:
        return 0

    @property
    def death_penalty(self) -> ctype.int32:
        return 0

    @property
    def inventory_max(self) -> ctype.int32:
        return 80

    @property
    def warehouse_max(self) -> ctype.int32:
        return 80

    @property
    def private_sell_max(self) -> ctype.int32:
        return 80

    @property
    def private_buy_max(self) -> ctype.int32:
        return 80

    @property
    def freight_max(self) -> ctype.int32:
        return 80

    @property
    def dwarf_receipt_max(self) -> ctype.int32:
        return 80

    @property
    def common_receipt_max(self) -> ctype.int32:
        return 80


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class ConsumeRates(BaseDataclass):
    mp: ctype.int32
    hp: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Effects(BaseDataclass):
    is_afraid: cython.bint = False
    is_confused: cython.bint = False
    is_faking_death: cython.bint = False
    is_flying: cython.bint = False
    is_muted: cython.bint = False
    is_physically_muted: cython.bint = False
    is_dead: cython.bint = False
    is_immobilized: cython.bint = False
    is_overloaded: cython.bint = False
    is_paralyzed: cython.bint = False
    is_riding: cython.bint = False
    is_pending_revive: cython.bint = False
    is_rooted: cython.bint = False
    is_sleeping: cython.bint = False
    is_stunned: cython.bint = False
    is_betrayed: cython.bint = False

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class EquippedItems(BaseDataclass):
    under: ctype.int32
    left_ear: ctype.int32
    right_ear: ctype.int32
    necklace: ctype.int32
    right_finger: ctype.int32
    left_finger: ctype.int32
    head: ctype.int32
    right_hand: ctype.int32
    left_hand: ctype.int32
    gloves: ctype.int32
    chest: ctype.int32
    legs: ctype.int32
    feet: ctype.int32
    back: ctype.int32
    double_handed: ctype.int32
    hair: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Limits(BaseDataclass):
    inventory: ctype.int32
    warehouse: ctype.int32
    freight: ctype.int32
    sell: ctype.int32
    buy: ctype.int32
    dwarf_recipe: ctype.int32
    common_recipe: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Reflections(BaseDataclass):
    damage_percent: ctype.int32
    magic_skill: ctype.int32
    physical_skill: ctype.int32
    absorb_percent: ctype.int32
    transfer_percent: ctype.int32

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Resists(BaseDataclass):
    breath: ctype.int32
    aggression: ctype.int32
    confusion: ctype.int32
    movement: ctype.int32
    sleep: ctype.int32
    fire: ctype.int32
    wind: ctype.int32
    water: ctype.int32
    earth: ctype.int32
    holy: ctype.int32
    dark: ctype.int32

@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class BaseStats(BaseDataclass):
    STR: ctype.int32
    CON: ctype.int32
    DEX: ctype.int32
    INT: ctype.int32
    WIT: ctype.int32
    MEN: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Stats(BaseDataclass):
    max_hp: ctype.int32
    max_mp: ctype.int32
    max_cp: ctype.int32
    regen_hp: cython.double
    regen_mp: cython.double
    regen_cp: cython.double
    gain_mp: cython.double
    gain_hp: cython.double
    physical_defense: ctype.int32
    magic_defense: ctype.int32
    physical_attack: ctype.int32
    magic_attack: ctype.int32
    physical_attack_speed: ctype.int32
    magic_attack_speed: ctype.int32
    magic_reuse_rate: ctype.int32
    shield_defense: ctype.int32
    critical_damage: ctype.int32
    pvp_physical_damage: ctype.int32
    pvp_magic_damage: ctype.int32
    pvp_physical_skill_damage: ctype.int32
    accuracy: ctype.int32
    physical_attack_range: ctype.int32
    magic_attack_range: ctype.int32
    physical_attack_angle: ctype.int32
    attack_count_max: ctype.int32
    run_speed: ctype.int32
    walk_speed: ctype.int32
    swim_run_speed: ctype.int32
    swim_walk_speed: ctype.int32
    ride_run_speed: ctype.int32
    ride_walk_speed: ctype.int32
    fly_run_speed: ctype.int32
    fly_walk_speed: ctype.int32
    base: BaseStats
    resists: Resists
    exp: ctype.int32long
    sp: ctype.int32
    level: ctype.int32
    evasion: ctype.int32
    recommends_received: cython.int
    recommends_left: cython.char
    move_multiplier: cython.double
    attack_speed_multiplier: cython.double
    karma: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Status(BaseDataclass):
    cp: ctype.int32
    hp: ctype.int32
    mp: ctype.int32

    weight_load: ctype.int32

    is_faking_death: cython.bint
    is_in_combat: cython.bint
    is_pvp: cython.bint
    is_running: cython.bint
    is_sitting: cython.bint
    is_hero: cython.bint
    is_noble: cython.bint
    is_private_store: cython.bint
    is_dwarf_craft_store: cython.bint
    is_mounted: cython.bint
    is_fishing: cython.bint
    is_invulnerable: cython.bint
    is_teleporting: cython.bint
    is_betrayed: cython.bint
    is_afraid: cython.bint
    is_confused: cython.bint
    is_flying: cython.bint
    is_muted: cython.bint
    is_physically_muted: cython.bint
    is_dead: cython.bint
    is_immobilized: cython.bint
    is_overloaded: cython.bint
    is_paralyzed: cython.bint
    is_riding: cython.bint
    is_pending_revive: cython.bint
    is_rooted: cython.bint
    is_sleeping: cython.bint
    is_stunned: cython.bint


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class LevelUpIncrease(BaseDataclass):
    base: cython.float
    add: cython.float
    mod: cython.float


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class LevelUpGain(BaseDataclass):
    level: ctype.int32
    hp: LevelUpIncrease
    cp: LevelUpIncrease
    mp: LevelUpIncrease


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class ClassInfo(BaseDataclass):
    id: cython.char
    name: str
    base_level: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class CharacterTemplate(BaseDataclass):
    class_info: ClassInfo
    stats: Stats
    race: cython.char
    level_up_gain: LevelUpGain
    spawn: Point3D

    collision_radius: cython.double
    collision_height: cython.double
    load: ctype.int32

    mp_consume_rate: ctype.int32
    hp_consume_rate: ctype.int32

    items: list


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class UpdateChecks(BaseDataclass):
    increase: ctype.int32long
    decrease: ctype.int32long
    interval: ctype.int32long


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class WeaponVulnerabilities(BaseDataclass):
    shield: ctype.int32
    sword: ctype.int32
    blunt: ctype.int32
    dagger: ctype.int32
    bow: ctype.int32
    pole: ctype.int32
    etc: ctype.int32
    fist: ctype.int32
    dual: ctype.int32
    dual_fist: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class Skill(BaseDataclass):
    activation_type: str
    target_type: ctype.int32
    type: ctype.int32


@cython.dataclasses.dataclass(kw_only=True)
@cython.cclass
cdef class WorldRegion(BaseDataclass):
    playable_objects: list[Playable] = cython.dataclasses.field(default_factory=list)
    visible_objects: list[Playable] = cython.dataclasses.field(default_factory=list)
    neighbours: list[WorldRegion] = cython.dataclasses.field(default_factory=list)
    tile_x: ctype.int32
    tile_y: ctype.int32
    active: cython.bint
